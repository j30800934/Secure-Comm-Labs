# #!/usr/bin/env python3
# from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes
# import gmpy2
# from sympy import mod_inverse




# n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
# e = 3
# ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

# # n is a prime, e is small, ct is smaller than n
# # print(long_to_bytes(gmpy2.root(ct, e)[0]))

# a = 123456789
# m = 17
# print(mod_inverse(a, m))  # Outputs the modular inverse of a mod m


import gmpy2
from Crypto.Util.number import long_to_bytes

# Given values
n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
e = 3
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

# Compute the cube root of the ciphertext (modulo n) and check if it's exact
root, is_exact = gmpy2.iroot(ct, e)

# If the root is exact, we can convert it to bytes
if is_exact:
    plaintext = long_to_bytes(int(root))
    print(f"Decrypted message: {plaintext.decode()}")
else:
    print("The root is not exact. Decryption failed.")
