from sage.all import *
from Crypto.Util.number import *
from Crypto.Cipher import AES
from pwn import *
import hashlib 
import json 

r = remote('socket.cryptohack.org', 13373, level = 'DEBUG')
param_a = json.loads(r.recvline().lstrip(b'Intercepted from Alice: ').rstrip(b'\n').decode())
p = param_a["p"]
g = param_a["g"]
A = param_a["A"]
param_b = json.loads(r.recvline().lstrip(b'Intercepted from Bob: ').rstrip(b'\n').decode())
B = param_b["B"]
param_enc = json.loads(r.recvline().lstrip(b'Intercepted from Alice: ').rstrip(b'\n').decode())
iv = param_enc["iv"]
enc = param_enc["encrypted"]

print(iv)
print(enc)

p1 = eval(p)
A1 = eval(A)

fake_prime = "0x6777ab111e5468d635eed4ddefa4cd115eecfae5970da42650535201710c5bb8086d63936be47ecbaf69f953d08dbe305b95e2c803a67b4da3091da447f75ce462c35e546f9ae176c541e491bd5e1c36c15f21fa40ef507d72c3da8c7f624eff4b44763b23b25d4ec1d8a7a38f15d079b5191d932b61cac22485313f6edac11b6d6237cc510a99991adfc2c75b311e4673185c86b49b21dcc59b365db04dcd93f32d254dbbff39052b1d1d4f41ceda39d832da1eaf0331fa30d5eb013dcd94317d14aa7d8065caf73"

p2 = int(fake_prime[2:],16)
print(r.recvuntil(b'Bob connects to you, send him some parameters: '))
r.sendline(b'{\"p\": \"' + fake_prime.encode() + b'\", \"g\": \"' + g.encode() + b'\", \"A\": \"' + A.encode() + b'\"}')
param_b = json.loads(r.recvline().lstrip(b'Bob says to you: ').rstrip(b'\n').decode())

B1 = eval(param_b["B"])
print(B1)
param_enc = json.loads(r.recvline().lstrip(b'Bob says to you: ').rstrip(b'\n').decode())


Zp = Zmod(p2)
g = Zp(2)
B1 = Zp(B1)
print(B1)

b = discrete_log(B1, g, g.order(), operation='*')
print(b)

b = 7273086812095034626784775786097754621334165238025575189513823623757449151828989133272386733165672487334918104579752730239236482456859355299966043051967152355891722647737316132882736754216386588471521625488245492658778640563255153908640240666465936742010092343138819760416990263824784017585372945862055710962051722860071532575482978715347226585309392243879335202050749293111270413003966719322119397363604669588801595943715334918202175411011553013930826415773226
A = 0xdf9640e15a77e68673442ec5387c8fd89a369520942eaa114979830670a07c62c6cc1766997456398af00994c6b361c7f890a9849c733cc1c8d3ebfd6e3507166ed6a6b28dbba4ba8d9bdcc80c8e7df1bd7d143f3639a9877b92767c019151aa49f336ce0473f91ad4f3c0221ae50f2ff45bcff5bb003b01afd2544f88caf8faea0ffb96c0f2713b474a6734b33a667f9de2764b1fb5aad9aca4a45d4c6d92e888409582a7ed52d71a043e3f77d22118111ec59596895a68465f226e83e424a7
g = 2
p = 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff
p1 = 287525814537951598447973417688676124298054833416051805540030298801177089522130059313787896137843226621031247296190495641098242503052387123691335498690980959013591315044488255658174941777514509092966736649058420580207421101458535831527560680714747189293206011040244668547928425875838160769862063010824818333538676510123326201572142689148252516286574007946803831702207301748037178585853117765440272174324474644318524661496114749834439336619803991900221082208951348476094393253900365683
B = 245994630587408513800398431517445206904010940780668197054744811026578147154747240671568784216178713298791106343282393581535929837451638045365867899233228184039427984350925080380023367311415105007701594445863542025170091415426240215991949930741742627349451194290545848359273531621473447367781175147747067929153212765475310779647053406699919562316714405877931258869301184734386085483626968022586739388914553270871179198807512521993949937594432998065982450798806369335253012479281311305

s = pow(A,b,p)

# iv = "0fdb43bd02784694d47223730af5eb18"
# enc = "d7983ea428a0deeb899b11da5becc2627eb8cfe48c0f02cbfd197add4da210ff"

# def is_pkcs7_padded(message):
#     padding = message[-message[-1]:]
#     return all(padding[i] == len(padding) for i in range(0, len(padding)))

# def pkcs7_unpad(message, block_size=16):
#     if len(message) == 0:
#         raise Exception("The input data must contain at least one byte")
#     if not is_pkcs7_padded(message):
#         return message
#     padding_len = message[-1]
#     return message[:-padding_len]

def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return plaintext

print(decrypt_flag(s,iv,enc))


# from Crypto.Util.number import *
# while True:
#     p = 2
#     while p.bit_length() < 1600:
#         p *= getPrime(16)
#     if p.bit_length() < 2048:
#         p = p + 1
#     if isPrime(p):
#         print(p)
#         break
#     else:
#         print('Failed')
 

# p = 287525814537951598447973417688676124298054833416051805540030298801177089522130059313787896137843226621031247296190495641098242503052387123691335498690980959013591315044488255658174941777514509092966736649058420580207421101458535831527560680714747189293206011040244668547928425875838160769862063010824818333538676510123326201572142689148252516286574007946803831702207301748037178585853117765440272174324474644318524661496114749834439336619803991900221082208951348476094393253900365683
# print(hex(p))


## crypto{n07_3ph3m3r4l_3n0u6h}