from sage.all import *
from Crypto.Util.number import *
from Crypto.Cipher import AES
from pwn import *
import hashlib 
import json 

r = remote('socket.cryptohack.org', 13373, level = 'DEBUG')
param_a = json.loads(r.recvline().lstrip(b'Intercepted from Alice: ').rstrip(b'\n').decode())
p = param_a["p"]
g = param_a["g"]
A = param_a["A"]
param_b = json.loads(r.recvline().lstrip(b'Intercepted from Bob: ').rstrip(b'\n').decode())
B = param_b["B"]
param_enc = json.loads(r.recvline().lstrip(b'Intercepted from Alice: ').rstrip(b'\n').decode())
iv = param_enc["iv"]
enc = param_enc["encrypted"]

print(iv)
print(enc)

p1 = eval(p)
A1 = eval(A)

fake_prime = "0x6777ab111e5468d635eed4ddefa4cd115eecfae5970da42650535201710c5bb8086d63936be47ecbaf69f953d08dbe305b95e2c803a67b4da3091da447f75ce462c35e546f9ae176c541e491bd5e1c36c15f21fa40ef507d72c3da8c7f624eff4b44763b23b25d4ec1d8a7a38f15d079b5191d932b61cac22485313f6edac11b6d6237cc510a99991adfc2c75b311e4673185c86b49b21dcc59b365db04dcd93f32d254dbbff39052b1d1d4f41ceda39d832da1eaf0331fa30d5eb013dcd94317d14aa7d8065caf73"

p2 = int(fake_prime[2:],16)
print(r.recvuntil(b'Bob connects to you, send him some parameters: '))
r.sendline(b'{\"p\": \"' + fake_prime.encode() + b'\", \"g\": \"' + g.encode() + b'\", \"A\": \"' + A.encode() + b'\"}')
param_b = json.loads(r.recvline().lstrip(b'Bob says to you: ').rstrip(b'\n').decode())

B1 = eval(param_b["B"])
print(B1)
param_enc = json.loads(r.recvline().lstrip(b'Bob says to you: ').rstrip(b'\n').decode())


Zp = Zmod(p2)
g = Zp(2)
B1 = Zp(B1)
print(B1)

b = discrete_log(B1, g, g.order(), operation='*')
print(b)

b = 7273086812095034626784775786097754621334165238025575189513823623757449151828989133272386733165672487334918104579752730239236482456859355299966043051967152355891722647737316132882736754216386588471521625488245492658778640563255153908640240666465936742010092343138819760416990263824784017585372945862055710962051722860071532575482978715347226585309392243879335202050749293111270413003966719322119397363604669588801595943715334918202175411011553013930826415773226
A = 0xdf9640e15a77e68673442ec5387c8fd89a369520942eaa114979830670a07c62c6cc1766997456398af00994c6b361c7f890a9849c733cc1c8d3ebfd6e3507166ed6a6b28dbba4ba8d9bdcc80c8e7df1bd7d143f3639a9877b92767c019151aa49f336ce0473f91ad4f3c0221ae50f2ff45bcff5bb003b01afd2544f88caf8faea0ffb96c0f2713b474a6734b33a667f9de2764b1fb5aad9aca4a45d4c6d92e888409582a7ed52d71a043e3f77d22118111ec59596895a68465f226e83e424a7
g = 2
p = 0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff
p1 = 287525814537951598447973417688676124298054833416051805540030298801177089522130059313787896137843226621031247296190495641098242503052387123691335498690980959013591315044488255658174941777514509092966736649058420580207421101458535831527560680714747189293206011040244668547928425875838160769862063010824818333538676510123326201572142689148252516286574007946803831702207301748037178585853117765440272174324474644318524661496114749834439336619803991900221082208951348476094393253900365683
B = 245994630587408513800398431517445206904010940780668197054744811026578147154747240671568784216178713298791106343282393581535929837451638045365867899233228184039427984350925080380023367311415105007701594445863542025170091415426240215991949930741742627349451194290545848359273531621473447367781175147747067929153212765475310779647053406699919562316714405877931258869301184734386085483626968022586739388914553270871179198807512521993949937594432998065982450798806369335253012479281311305

s = pow(A,b,p)

# iv = "0fdb43bd02784694d47223730af5eb18"
# enc = "d7983ea428a0deeb899b11da5becc2627eb8cfe48c0f02cbfd197add4da210ff"

# def is_pkcs7_padded(message):
#     padding = message[-message[-1]:]
#     return all(padding[i] == len(padding) for i in range(0, len(padding)))

# def pkcs7_unpad(message, block_size=16):
#     if len(message) == 0:
#         raise Exception("The input data must contain at least one byte")
#     if not is_pkcs7_padded(message):
#         return message
#     padding_len = message[-1]
#     return message[:-padding_len]

def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return plaintext

print(decrypt_flag(s,iv,enc))


# from Crypto.Util.number import *
# while True:
#     p = 2
#     while p.bit_length() < 1600:
#         p *= getPrime(16)
#     if p.bit_length() < 2048:
#         p = p + 1
#     if isPrime(p):
#         print(p)
#         break
#     else:
#         print('Failed')
 

# p = 287525814537951598447973417688676124298054833416051805540030298801177089522130059313787896137843226621031247296190495641098242503052387123691335498690980959013591315044488255658174941777514509092966736649058420580207421101458535831527560680714747189293206011040244668547928425875838160769862063010824818333538676510123326201572142689148252516286574007946803831702207301748037178585853117765440272174324474644318524661496114749834439336619803991900221082208951348476094393253900365683
# print(hex(p))


## crypto{n07_3ph3m3r4l_3n0u6h}

# This script connects to a remote server and intercepts Diffie-Hellman parameters and an AES-encrypted message. It then constructs a fake prime for the Diffie-Hellman calculation, calculates the shared secret using the discrete logarithm of a received value, and uses it to derive an AES key. The script proceeds to decrypt the flag using the derived key and AES in CBC mode. The decrypted plaintext is returned and printed.